import React, { memo, useCallback, useEffect, useRef, useState } from "react";
import { Helmet } from "react-helmet";
import { BiHide, BiShow } from "react-icons/bi";
import Config, { routes } from "../Config";
import { Task } from "../constants";
import styles from "../styles/History.less";
import utils from "../utils";
import { formatDate, formatThumbnailURL } from "../utils/encoding";
import { useIntersectionObserver, useMounted } from "../utils/hooks";
import websocket, { GetHistory, ReadChapter, UnreadChapter } from "../websocket";
import Anchor from "./Anchor";
import Header from "./Header";
import NotFound from "./NotFound";
import Picture from "./Picture";
import Spinner from "./Spinner";

interface ReadGroup {
  id: string;
  title: string;
  cover: string;

  histories: ReadState[];
}

type ReadGroups = { [key: string]: ReadGroup };

interface HistoryEntry {
  id: string;
  title: string;
  cover: string;
  histories: ReadState[];
}

const formatHistory = (history: ReadState) => {
  if (history.chapterTitle === "Oneshot") {
    return history.chapterTitle;
  }

  const arr: string[] = [];

  if (history.volume) arr.push(`Vol. ${history.volume}`);
  if (history.chapter) arr.push(`Ch. ${history.chapter}`);
  if (history.chapterTitle) arr.push(`- ${history.chapterTitle}`);

  return arr.join(" ") || "Ch. 0";
};

const makeEntries = (histories: ReadState[], prev?: ReadGroups) =>
  histories.reduce((entries, { mangaId: id, mangaTitle: title, banner, cover, ...h }) => {
    const e = (entries[id] ??= { id, title, cover, histories: [] });

    if (prev) {
      const idx = e.histories.findIndex(it => it.id === h.id);
      let unshift = false;

      if (idx >= 0) {
        if (e.histories[idx].updatedAt !== h.updatedAt) {
          e.histories.unshift({ ...e.histories.splice(idx, 1)[0], ...h });
          unshift = true;
        }
      } else if ((h.updatedAt || h.createdAt) > (e.histories[0]?.updatedAt || e.histories[0]?.createdAt || 0)) {
        /* if (e.histories.length >= Config.history.maxItems) {
          e.histories.pop();
        } */
        e.histories.unshift(h);
        unshift = true;
      }

      if (unshift) {
        entries = { [id]: e, ...entries };
      }
    } else {
      // else if (e.histories.length < Config.history.maxItems) {
      e.histories.push(h);
    }

    return entries;
  }, prev || ({} as ReadGroups));

/**
 * Ths function returns modified groups and a state
 * whether modification has occured.
 *
 * State will be false when:
 * - Group does not exists inside groups
 * - History does not exists inside group.histories
 *
 * When history exists, old value will be replaced
 * and group will be unshifted/moved to the first index.
 */
const synchronizeHistory = (groups: ReadGroups, { mangaId, ...h }: ReadState): [ReadGroups, boolean] => {
  const group = groups[mangaId];
  if (!group) return [groups, false];

  const idx = group.histories.findIndex(e => e.id === h.id);
  if (idx >= 0) {
    group.histories.unshift({ ...group.histories.splice(idx, 1)[0], ...h });
    groups = { [mangaId]: group, ...groups };
  }

  return [groups, idx >= 0];
};

const Item = ({ mangaId, data }: { mangaId: string; data: ReadState }) => {
  const mountedRef = useMounted();
  const mutex = useRef<boolean>();

  const [isVisible, setIsVisible] = useState<boolean>();
  const ref = useIntersectionObserver<HTMLLIElement>(
    () => {
      if (!mountedRef.current) return;
      setIsVisible(true);
    },
    { once: true }
  );

  const isUnreaded = !data.readed && !data.lastViewed;
  const updateReadState = useCallback(async () => {
    if (mutex.current) return;
    mutex.current = true;

    let error: string;
    if (isUnreaded) {
      ({ error } = await ReadChapter(data.chapterId));
    } else {
      ({ error } = await UnreadChapter(data.chapterId));
    }

    if (!mountedRef.current) return;
    if (error) console.error(error);
    mutex.current = false;
  }, [isUnreaded]);

  useEffect(() => {
    if (ref.current && mountedRef.current && isVisible) {
      ref.current.classList.remove(styles.hidden);
    }
  }, [isVisible]);

  return (
    <li styleName="hidden" data-deleted={isUnreaded || undefined} ref={ref}>
      {isVisible && (
        <>
          <Anchor to={`${routes.reader}/${mangaId}/${data.chapterId}`}>
            <h3>{formatHistory(data)}</h3>
            <span styleName="info">
              {formatDate(data.updatedAt || data.createdAt)}
              {!isUnreaded && (
                <>
                  {!!data.lastViewed && ` • ${data.readed ? "Re-reading" : "Reading"}`}
                  {` • ${data.lastViewed ? `Page ${data.lastViewed}` : "Finished"}`}
                </>
              )}
            </span>
          </Anchor>
          <button type="button" title={isUnreaded ? "Mark as readed" : "Mark as unreaded"} onClick={updateReadState}>
            {isUnreaded ? <BiShow /> : <BiHide />}
          </button>
        </>
      )}
    </li>
  );
};

const MemoizedItem = memo(
  Item,
  (prev, next) =>
    prev.data?.readed === next.data?.readed &&
    prev.data?.lastViewed === next.data?.lastViewed &&
    prev.data?.updatedAt === next.data?.updatedAt
);

const Entry = ({ data }: { data: ReadGroup }) => {
  const mountedRef = useMounted();

  const [isVisible, setIsVisible] = useState<boolean>();
  const ref = useIntersectionObserver<HTMLDivElement>(
    ({ isIntersecting }) => {
      if (!isIntersecting) return;
      setIsVisible(true);
    },
    { once: true }
  );

  useEffect(() => {
    if (ref.current && mountedRef.current && isVisible) {
      ref.current.classList.remove(styles.hidden);
    }
  }, [isVisible]);

  return (
    <div styleName="group hidden" ref={ref}>
      <div styleName="figure">
        <div styleName="cover">
          {isVisible && (
            <Anchor to={`${routes.manga}/${data.id}`}>
              <Picture src={formatThumbnailURL(data)} div />
            </Anchor>
          )}
        </div>
      </div>
      <div styleName="content">
        <h2>
          <Anchor to={`${routes.manga}/${data.id}`}>{data.title}</Anchor>
        </h2>
        <ul styleName="list">
          {data.histories.slice(0, Config.history.maxItems).map(it => (
            <MemoizedItem mangaId={data.id} data={it} key={it.id} />
          ))}
        </ul>
      </div>
    </div>
  );
};

const History = () => {
  const mountedRef = useMounted();
  const ref = useRef<HTMLDivElement>();

  const [isLoading, setIsLoading] = useState(true);
  const [isPaginating, setIsPaginating] = useState(false);

  const [data, setData] = useState<ReadGroups>();
  const [currentPage, setCurrentPage] = useState<number>(1);
  const mutex = useRef<boolean>();

  useEffect(() => {
    const getHistory = async () => {
      const { response, error } = await GetHistory(Config.history.limit);
      if (!mountedRef.current) return;

      if (response) {
        setData(prevState => makeEntries(response, prevState));
      } else if (error) {
        console.error(error);
      }
    };

    const updateHistory = ({ body }: IncomingMessage<ReadState>) => {
      if (!body) return;
      console.info("[History] Synchronizing history...");

      let ok = true;
      setData(prevState => {
        [prevState, ok] = synchronizeHistory(prevState, body);
        return prevState;
      });

      if (!ok) getHistory();
    };

    const updateHistories = ({ body }: IncomingMessage<ReadState[]>) => {
      if (!body) return;
      console.info("[History] Synchronizing histories...");

      let ok = true;
      setData(prevState => {
        for (let i = 0; i < body.length; i++) {
          let exists: boolean;
          [prevState, exists] = synchronizeHistory(prevState, body[i]);
          if (ok && !exists) {
            ok = false;
          }
        }
        return prevState;
      });

      if (!ok) getHistory();
    };

    const synchronizeHistories = ({ body }: IncomingMessage<ReadState[]>) => {
      if (!body) return;

      setData(state => ({ ...state }));
    };

    const removeHandlers = [
      websocket.Handle(Task.ReadPage, updateHistory),
      websocket.Handle(Task.ReadChapter, updateHistories),
      websocket.Handle(Task.UnreadChapter, updateHistories)
    ];

    return () => {
      removeHandlers.forEach(remove => remove());
    };
  }, []);

  useEffect(() => {
    if (isPaginating || mutex.current) {
      return;
    }
    if (!isLoading) setIsPaginating(true);

    GetHistory(Config.history.limit, currentPage).then(({ response, error }) => {
      if (!mountedRef.current) return;

      if (response) {
        setData(prevState => makeEntries(response, prevState));
      } else if (error) {
        console.error(error);
      } else {
        mutex.current = true;
      }

      setIsLoading(false);
      setIsPaginating(false);
    });
  }, [currentPage]);

  useEffect(() => {
    if (isLoading || isPaginating || !ref.current || mutex.current || !data?.length) {
      return undefined;
    }

    const observer = new IntersectionObserver(
      oEntries => {
        oEntries.forEach(oEntry => {
          if (!mountedRef.current || !oEntry.isIntersecting) {
            return;
          }
          observer.disconnect();
          setCurrentPage(x => x + 1);
        });
      },
      { rootMargin: "200px" }
    );

    window.requestAnimationFrame(() => {
      const items = ref.current.getElementsByClassName(styles.group);
      if (items) {
        observer.observe(items[items.length - 1]);
      }
    });

    return () => {
      observer.disconnect();
    };
  }, [data, isLoading, isPaginating]);

  return (
    <>
      <Helmet>
        <title>History - Nonbiri</title>
      </Helmet>

      <Header />
      <div styleName="history" ref={ref}>
        {isLoading ? (
          <Spinner styleName="loading" />
        ) : (
          (() =>
            utils.IsObjectEmpty(data) ? (
              <NotFound title="No history">
                <p>You have not readed any manga.</p>
              </NotFound>
            ) : (
              <div styleName="historyContent">
                {Object.values(data || {}).map((e, i) => (
                  // eslint-disable-next-line react/no-array-index-key
                  <Entry data={e} key={`${e.id}-${i}`} />
                ))}
                {isPaginating && <Spinner styleName="pagination" />}
              </div>
            ))()
        )}
      </div>
    </>
  );
};

export default History;
